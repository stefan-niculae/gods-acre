from typing import Optional, Union
from datetime import datetime

from django.core.urlresolvers import reverse
from django.utils.safestring import mark_safe

from .utils import NBSP


DEFAULT_HEAD_LENGTH = 2


""" 
Links and anchors 
"""

def add_link(model_name: str, popup: bool = True) -> str:
    """
    Link building from https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#reversing-admin-urls

    Args:
        model_name (str): name in snake_case (with underscores) - what to build the link for
        popup (bool): whether the link should open in a popup or new page

    Returns:
        link (str): to change page

    Examples:    
        >>> add_link('model')
        '/cemetery/model/add?_to_field=id&_popup=1'
    """
    model_name = model_name.replace('_', '').lower()  # delete underscores
    link = reverse(f'admin:cemetery_{model_name}_add')

    link += '?_to_field=id'  # HACK: hover over add links for other models and this is what is appended
    if popup:
        link += '&_popup=1'  # HACK: see above

    return link


def entity_link(model_name: str, pk) -> str:
    """
    Link building from https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#reversing-admin-urls

    Args:
        model_name (str): name in snake_case (with underscores) - what to build the link for
        pk: primary key of entity to change

    Returns:
        link (str): to change/edit page of the one entity
    """
    model_name = model_name.replace('_', '').lower()  # delete underscores
    link_name = f'admin:cemetery_{model_name}_change'
    return reverse(link_name, args=(pk,))


def entity_tag(entity) -> Optional[str]:
    """
    Links to the edit/change page for the given `entity`
    Wraps an anchor (generated by `entity_link`) around the entity representation

    Args:
        entity (django.models.model): or something that has `pk` attribute: int 

    Returns:
        tag (str?): html anchor

    Examples:
        MyModel(pk=1) ->
        <a href="/cemetery/mymodel/change/1">My model #1</a>
    """
    if not entity:
        return
    link = entity_link(entity.__class__.__name__, entity.pk)
    return mark_safe(f'<a href="{link}">{entity}</a>')


def head_plus_more(entities, head_length: Optional[int] = None) -> (Optional[str], Optional[str]):
    """
    Show the first item. Others are shown as (+n) more

    Args:
        entities: iterable 
        head_length: how many entities to be displayed fully

    Returns:
        tuple of (list of head elements, tail summary string), or (None, None)

    Examples:
        >>> head_plus_more(['abc'])
        (['abc'], '')

        >>> head_plus_more(['abc'], head_length=1)
        (['abc'], '')

        >>> head_plus_more(['abc'], head_length=10)
        (['abc'], '')

        >>> head_plus_more(['abc', 'def', 'xyz'], head_length=1)
        (['abc'], '(+2)')

        >>> head_plus_more(['abc', 'def', 'xyz'], head_length=2)
        (['abc', 'def'], '(+1)')

        >>> head_plus_more([])
        (None, None)
    """
    if not entities:
        return None, None  # not a single None in order to keep return count consistent

    head_length = head_length or DEFAULT_HEAD_LENGTH

    tail_length = len(entities) - head_length
    tail_summary = '' if tail_length <= 0 else f'{NBSP}(+{tail_length})'

    return entities[:head_length], tail_summary


def display_head_links(query, head_length: Optional[int] = None) -> Optional[str]:
    """
    Links the first item and shows the others.

    Args:
        query: Django query manager (or something that has .all = () -> list)
        head_length: passed to `head_plus_more`

    Returns:
        tag (str?): html for anchor
    """
    if not query:
        return

    entities = query.all()
    head, others = head_plus_more(entities, head_length)
    if not head:  # no entities
        return

    links = map(entity_tag, head)
    return f',{NBSP}'.join(links) + others


"""
String manipulation
"""

def truncate(string: Optional[str], max_len: int = 20) -> Optional[str]:
    """
    Caps the string to `max_len`. Inserts an ellipsis if necessary

    :param string:  what to truncate; if None, will return None 
    :param max_len: maximum number of characters (including ellipsis)
    :return:        truncated string

    >>> truncate('abc', max_len=4)
    'abc'

    >>> truncate('abcdxyz', max_len=4)
    'abc…'

    >>> truncate(None)
    """
    if not string:
        return
    max_len -= 1  # to account for the length of the ellipsis
    ellipsis_str = '…' if len(string) > max_len else ''
    return string[:max_len] + ellipsis_str


def title_case(string: Optional[str]) -> Optional[str]:
    """
    Convert into Title Case

    Examples:
        >>> title_case('abc  dEf')
        'Abc Def'
        >>> title_case(None)
        >>> title_case('mary-jane')
        'Mary-Jane'
        >>> title_case('s.r.l')
        'S.R.L'
    """
    if string is None:
        return None
    return ' '.join(word.capitalize() for word in string.split())


def initials(names: str) -> str:
    return '.'.join(n[0] for n in names.split())


"""
Number manipulation
"""

def year_shorthand_to_full(shorthand: Union[int, str], threshold: int = 50) -> int:
    """

    Args:
        shorthand (int | str): last two digits in a year (eg: 99, 00, 15) 
        threshold (int): after what year it is considered 2000s not 1900s  (eg: for 50: 51 -> 1951 but 49 -> 2049 

    Returns:
        year (int): full year (eg: 1999, 2000, 2015)

    Examples:
        >>> year_shorthand_to_full(99)
        1999
        >>> year_shorthand_to_full(0)
        2000
        >>> year_shorthand_to_full(15)
        2015
        >>> year_shorthand_to_full(1994)
        1994
        >>> year_shorthand_to_full(2017)
        2017
    """
    shorthand = int(shorthand)

    if shorthand >= 100:
        return shorthand  # not actually a shorthand

    if shorthand > threshold:
        return 1900 + shorthand
    else:
        return 2000 + shorthand


def year_to_shorthand(year: int) -> str:
    """
    >>> year_to_shorthand(1999)
    '99'
    >>> year_to_shorthand(2001)
    '01'
    """
    as_str = str(year % 100)  # just the last two digits, eg: 1999 ~> 99
    if len(as_str) < 2:  # show 2001 as 01 instead of just 1
        return '0' + as_str
    return as_str


"""
Date manipulation
"""

def display_date(date):
    """
    If only the year portion of the date was entered, show only that
    >>> display_date(datetime(year=2017, month=7, day=18))
    datetime.datetime(2017, 7, 18, 0, 0)

    >>> display_date(datetime(year=2017, month=1, day=1))
    2017
    """
    if date.month == date.day == 1:
        return date.year
    return date
